% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scregclust.R
\name{scregclust}
\alias{scregclust}
\title{Uncover gene modules and associated regulators from single cell data}
\usage{
scregclust(
  expression,
  genesymbols,
  is_regulator,
  target_cluster_start,
  penalization,
  sample_assignment = NULL,
  split1_proportion = 0.5,
  total_proportion = 1,
  prior_indicator = NULL,
  prior_genesymbols = NULL,
  prior_baseline = 1e-06,
  prior_weight = 0.5,
  min_cluster_size = 0L,
  allocate_per_obs = TRUE,
  cluster_inertia = 0,
  noise_threshold = 0.025,
  center = TRUE,
  n_cycles = 50L,
  use_kmeanspp_init = TRUE,
  n_init_clusterings = 50L,
  max_optim_iter = 10000L,
  compute_predictive_r2 = TRUE,
  compute_cross_cluster_r2 = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{expression}{\verb{p x n} matrix of pre-processed single cell expression
data with \code{p} rows of genes and \code{n} columns of cells.}

\item{genesymbols}{a vector of gene names corresponding to rows of
\code{expression}. Has to be of length \code{p}.}

\item{is_regulator}{an indicator vector, telling which rows in \code{expression}
are candidate regulators. Has to be of length \code{p}.}

\item{target_cluster_start}{is the start cluster assignment for the rows in
\code{expression} that correspond to target genes, i.e. those for
which \code{is_regulator == 0L}. Alternatively, an integer
indicating the number of clusters. An initial clustering is
performed on the cross-correlation matrix of targets and genes
on the first dataset after data splitting.}

\item{penalization}{sparsity penalty controlling the amount of regulators
used for each cluster. Either a single positive number
or a vector of positive numbers.}

\item{sample_assignment}{a vector of sample assignment for each cell, can
be used to perform the data splitting with
stratification. Has to be of length \code{n}.
No stratification if \code{NULL} is supplied.}

\item{split1_proportion}{the proportion to use for the first dataset during
data splitting. The proportion for the second
dataset is \code{1 - split1_proportion}. If stratification
with \code{sample_assignment} is used, then the proportion
of each strata is controlled.}

\item{total_proportion}{can be used to only use a proportion of the supplied
observations. The proportion of the first dataset
during data splitting in relation to the full
dataset will be
\code{total_proportion * split1_proportion}.}

\item{prior_indicator}{an indicator matrix (sparse or dense) of size q x q
that indicates whether there is a known functional
relationship between two genes. Ideally, this is
supplied as a sparse matrix (\code{sparseMatrix}
in the \code{Matrix} package). If not, then the matrix
is converted to one.}

\item{prior_genesymbols}{a vector of gene names of length q corresponding
to the rows/columns in \code{prior_indicator}. Does not
have to be the same as \code{genesymbols}, but only
useful if there is overlap.}

\item{prior_baseline}{positive baseline for the network prior. The larger
this parameter is, the less impact the network prior
will have.}

\item{prior_weight}{a number between 0 and 1 indicating the strength of the
prior in relation to the data. 0 ignores the prior and
makes the algorithm completely data-driven. 1 uses only
the prior during cluster allocation.}

\item{min_cluster_size}{minimum required size of target genes for a cluster.}

\item{allocate_per_obs}{whether cluster allocation should be performed for
each observation in the second data split separately.
If FALSE, clusters are allocated on the aggregate
sum of squares across all observations in the
second data split}

\item{cluster_inertia}{a target gene can only change its cluster assignment
if \verb{>= cluster_inertia} more observations in
the second split vote for the new cluster compared
to the old cluster}

\item{noise_threshold}{threshold for the best R2 of a target gene before
it gets identified as noise.}

\item{center}{whether or not genes should be centered}

\item{n_cycles}{number of clustering cycles}

\item{use_kmeanspp_init}{use kmeans++ for cluster initialization if
\code{target_cluster_start} is a single integer;
otherwise use kmeans with random initial cluster
centers}

\item{n_init_clusterings}{number of initial initialisation runs}

\item{max_optim_iter}{maximum number of iterations during optimization}

\item{compute_predictive_r2}{whether to compute predictive R2 per cluster
and regulator importance}

\item{compute_cross_cluster_r2}{whether to compute cross cluster R2}

\item{verbose}{whether to print progress}
}
\value{
an object of S3 class \code{scregclust} containing
\item{penalization}{the supplied penalization argument}
\item{results}{a list of results, one for each supplied element in
\code{penalization}. See details.}
\item{target_cluster_start}{initial clustering for target genes (i.e. those
with \code{is_regulator == 0})}
}
\description{
Use the scRegClust algorithm to determine gene modules and associated
regulatory programs from single cell data.
}
\details{
The list of \code{results} returned by this function contain the following:

For each supplied penalization parameter, \code{results} contains one list
which contains the current \code{penalization} parameter, the supplied
\code{genesymbols} after filtering (as used during fitting), the supplied
\code{is_regulator} vector after filtering (as used during fitting), as well as
an \code{output} object. It is possible that the algorithm ends in a cycle
instead of a unique final constellation. Therefore, \code{output} is a list
with each element itself being a list with the following contents:
\describe{
\item{\code{reg_table}}{a regulator table, a matrix of weights for each
regulator and cluster}
\item{\code{cluster}}{the cluster assignments for all genes (including
regulators); regulators are placed in clusters with the
highest accumulated correlation between target genes
and regulators}
\item{\code{r2}}{best r2 value for target genes}
\item{\code{models}}{regulator selection for each cluster}
\item{\code{signs}}{regulator signs for each cluster}
\item{\code{weights}}{average regulator coefficient for each cluster}
\item{\code{coeffs}}{list of regulator coefficient matrices for each cluster}
}
}
